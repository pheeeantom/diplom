CoffeeScript добавляет «синтаксический сахар» для JavaScript. Он вводит более короткий синтаксис, который позволяет писать чистый и лаконичный код. Обычно такое нравится Ruby-программистам.
TypeScript концентрируется на добавлении «строгой типизации» для упрощения разработки и поддержки больших и сложных систем. Разработан Microsoft.
Flow тоже добавляет типизацию, но иначе. Разработан Facebook.
Dart стоит особняком, потому что имеет собственный движок, работающий вне браузера (например, в мобильных приложениях). Первоначально был предложен Google, как замена JavaScript, но на данный момент необходима его транспиляция для запуска так же, как для вышеперечисленных языков.
Brython транспилирует Python в JavaScript, что позволяет писать приложения на чистом Python без JavaScript.

Comet — любая модель работы веб-приложения, при которой постоянное HTTP-соединение позволяет веб-серверу отправлять (push) данные браузеру без дополнительного запроса со стороны браузера. Благодаря comet-приложениям клиент в режиме реального времени может взаимодействовать с сервером, опираясь на постоянное (или там, где не представляется возможным, длительное (long polling)) соединение HTTP.

На практике «лёгкие» редакторы могут иметь множество плагинов, включая автодополнение и анализаторы синтаксиса на уровне директории, поэтому границы между IDE и «лёгкими» редакторами размыты.

Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в ${…}.

Возведение в степень **.

a = b = c = 2 + 2;

outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let input = prompt(`Значение на координатах (${i},${j})`, '');
    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) break outer; // (*)
    // сделать что-нибудь со значениями...
  }
}
alert('Готово!');

function showMessage(from, text = "текст не добавлен")

Небольшие функции не только облегчают тестирование и отладку – само существование таких функций выполняет роль хороших комментариев! - *потому что в стеке вызовов будет написано имя функции и ясно будет где произошла ошибка не отвлекаясь на лишнее а еще можно чекать его возвращаемое значение

function sayHi() {   // (1) создаём
  alert( "Привет" );
}
let func = sayHi;    // (2) копируем
func(); // Привет    // (3) вызываем копию (работает)!
sayHi(); // Привет   //     прежняя тоже работает (почему бы нет)

https://learn.javascript.ru/function-expressions

Можно передавать функцию как аргумент

Не должно быть более 9 строк кода подряд без вертикального отступа.

let user = {
  name,  // тоже самое, что и name:name
  age: 30
};

let user = { name: "John", age: 30 };
alert( "age" in user ); // true, user.age существует
alert( "blabla" in user ); // false, user.blabla не существует
let key = "age";
alert( key in user ); // true, имя свойства было взято из переменной key
let obj = {
  test: undefined
};
alert( obj.test ); //  выведет undefined, значит свойство не существует?
alert( "test" in obj ); // true, свойство существует!

let user = {
  name: "John",
  age: 30,
  isAdmin: true
};
for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}

Только для целочисленных свойств, остальные в порядке создания
let codes = {
  "49": "Германия",
  "41": "Швейцария",
  "44": "Великобритания",
  // ..,
  "1": "США"
};
for (let code in codes) {
  alert(code); // 1, 41, 44, 49
}

Переменная хранит не сам объект, а его «адрес в памяти», другими словами «ссылку» на него. Когда переменная объекта копируется – копируется ссылка, сам же объект не дублируется.

let clone = Object.assign({}, user);

Мы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы не изобретать велосипед, использовать готовую реализацию — метод _.cloneDeep(obj) из JavaScript-библиотеки lodash.

let num = Number("123"); // превращает строку в число

let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей
alert( 7.3e9 );  // 7.3 миллиардов (7,300,000,000)
let ms = 1e-6; // шесть нулей, слева от 1

Для цветов и кодировкисимволов:
alert( 0xff ); // 255
alert( 0xFF ); // 255 (то же самое, регистр не имеет значения)

let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

Забавно, но можно использовать 36-разрядную систему счисления для получения короткого представления большого числового идентификатора. К примеру, для создания короткой ссылки. Для этого просто преобразуем его в 36-разрядную систему счисления:
alert( (123456).toString(36) ); // 2n9c

Иначе было бы 0.30000000000000004:
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3

Иногда можно попробовать полностью отказаться от дробей. Например, если мы в нашем интернет-магазине начнём использовать центы вместо долларов. Но что будет, если мы применим скидку 30%? На практике у нас не получится полностью избавиться от дроби. Просто используйте округление, чтобы отрезать «хвосты», когда надо.

isNaN(value) преобразует значение в число и проверяет является ли оно NaN
isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity
Помните, что пустая строка интерпретируется как 0 во всех числовых функциях, включаяisFinite.

Существует специальный метод Object.is, который сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях

Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число.
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5
alert( parseInt('12.3') ); // 12, вернётся только целая часть
alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке
alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, без 0x тоже работает
alert( parseInt('2n9c', 36) ); // 123456

Внутренний формат для строк — всегда UTF-16, вне зависимости от кодировки страницы.

Ещё одно преимущество обратных кавычек — они могут занимать более одной строки

for (let char of "Hello") {
  alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т. д.)
}

Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда.

Ели делать просто иф то не будет работать для 0 позиции
let str = "Widget with id";
if (str.indexOf("Widget") != -1) {
    alert("Совпадение есть"); // теперь работает
}

Просто запомните: if (~str.indexOf(…)) означает «если найдено».

let str = "stringify";
// ring, получаем 4 символа, начиная с позиции 2
alert( str.substr(2, 4) );
let str = "stringify";
// gi, получаем 2 символа, начиная с позиции 4 с конца строки
alert( str.substr(-4, 2) );

console.log('ä'.localeCompare('z', 'de')); // отрицательное значение: в немецком буква ä идёт рядом с буквой a
console.log('ä'.localeCompare('z', 'sv')); // положительное значение: в шведском буква ä следует после буквы z

normalize() для перевода диакритических знаков

В массиве могут храниться элементы любого типа.

Другими словами, arr.at(i):
это ровно то же самое, что и arr[i], если i >= 0.
для отрицательных значений i, он отступает от конца массива.

let map = new Map();
map.set("1", "str1");    // строка в качестве ключа
map.set(1, "num1");      // цифра как ключ
map.set(true, "bool1");  // булево значение как ключ
// помните, обычный объект Object приводит ключи к строкам?
// Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:
alert(map.get(1)); // "num1"
alert(map.get("1")); // "str1"
alert(map.size); // 3

Map может использовать объекты в качестве ключей.

map.set("1", "str1")
  .set(1, "num1")
  .set(true, "bool1");

let john = { name: "John" };
let john1 = { name: "John" };
// давайте сохраним количество посещений для каждого пользователя
let visitsCountMap = new Map();
// объект john - это ключ для значения в объекте Map
visitsCountMap.set(john, 123);
visitsCountMap.set(john1, 321);
alert(visitsCountMap.get(john)); //123
alert(visitsCountMap.get(john1)); //321

То есть ключ у мап в качестве объекта сравнивает по адресу в памяти

Создать мап из объекта: let map = new Map(Object.entries(obj));

let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);
// prices = { banana: 1, orange: 2, meat: 4 }

let obj = Object.fromEntries(map.entries()); // создаём обычный объект (*)
let obj = Object.fromEntries(map); // убрать .entries() тоже самое

Основная «изюминка» Set – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз.

WeakMap: Ключ только объект. Теперь, если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён из памяти (и из объекта WeakMap) автоматически. Мы кладём эти данные в WeakMap, используя объект как ключ, и когда сборщик мусора удалит объекты из памяти, ассоциированные с ними данные тоже автоматически исчезнут.

Можно кешировать сложные функции:
// 📁 cache.js
let cache = new WeakMap();
// вычисляем и запоминаем результат
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* вычисляем результат для объекта */ obj;

    cache.set(obj, result);
  }
  return cache.get(obj);
}
// 📁 main.js
let obj = {/* какой-то объект */};
let result1 = process(obj);
let result2 = process(obj);
// ...позже, когда объект больше не нужен:
obj = null;
// Нет возможности получить cache.size, так как это WeakMap,
// но он равен 0 или скоро будет равен 0
// Когда сборщик мусора удаляет obj, связанные с ним данные из кеша тоже удаляются

может быть только один [[Prototype]]. Объект не может наследоваться от двух других объектов.

Если бы у нас были другие объекты, такие как bird, snake и т.д., унаследованные от animal, они также получили бы доступ к методам animal. Но this при вызове каждого метода будет соответствовать объекту (перед точкой), на котором происходит вызов, а не animal. Поэтому, когда мы записываем данные в this, они сохраняются в этих объектах.
В результате методы являются общими, а состояние объекта — нет.

let rabbit = new Rabbit("White Rabbit");
let rabbit2 = new rabbit.constructor("Black Rabbit");
Это удобно, когда у нас есть объект, но мы не знаем, какой конструктор использовался для его создания (например, он мог быть взят из сторонней библиотеки), а нам необходимо создать ещё один такой объект.

let obj = {
  0: "Hello",
  1: "world!",
  length: 2,
};
obj.join = Array.prototype.join;
alert( obj.join(',') ); // Hello,world!

И JavaScript движки хорошо оптимизированы для этого. Изменение прототипа «на лету» с помощью Object.setPrototypeOf или obj.__proto__= – очень медленная операция, которая ломает внутренние оптимизации для операций доступа к свойствам объекта. Так что лучше избегайте этого кроме тех случаев, когда вы знаете, что делаете, или же когда скорость JavaScript для вас не имеет никакого значения.

Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable вfalse для всех методов в "prototype". И это хорошо, так как если мы проходимся циклом for..in по объекту, то обычно мы не хотим при этом получать методы класса.

Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.

function makeClass(phrase) {
  // объявляем класс и возвращаем его
  return class {
    sayHi() {
      alert(phrase);
    };
  };
}
// Создаём новый класс
let User = makeClass("Привет");
new User().sayHi(); // Привет

class User {
  ['say' + 'Hi']() {
    alert("Привет");
  }
}
new User().sayHi();

class User {
  name = "Аноним";
  sayHi() {
    alert(`Привет, ${this.name}!`);
  }
}
new User().sayHi();

writable – если true, свойство можно изменить, иначе оно только для чтения.
enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
configurable – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.

Определение свойства как неконфигурируемого – это дорога в один конец. Мы не сможем отменить это действие, потому что defineProperty не работает с неконфигурируемыми свойствами.

let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));

Снаружи свойство-аксессор выглядит как обычное свойство. В этом и заключается смысл свойств-аксессоров. Мы не вызываем user.fullName как функцию, а читаем как обычное свойство: геттер выполнит всю работу за кулисами.

Таким образом, само имя хранится в _name, доступ к которому производится через геттер и сеттер.
Технически, внешний код всё ещё может получить доступ к имени напрямую с помощью user._name, но существует широко известное соглашение о том, что свойства, которые начинаются с символа "_", являются внутренними, и к ним не следует обращаться из-за пределов объекта.

if (true) {
  var test = true; // используем var вместо let
}
alert(test); // true, переменная существует вне блока if

Если в блоке кода дважды объявить одну и ту же переменную let, будет ошибка. Используя var, можно переобъявлять переменную сколько угодно раз. Повторные var игнорируются. Если дополнительно присвоить значение, то переменная примет новое значение.

Поскольку все объявления переменных var обрабатываются в начале функции, мы можем ссылаться на них в любом месте. Однако, переменные имеют значение undefined до строки с присвоением значения.
В обоих примерах выше вызов alert происходил без ошибки, потому что переменная phrase уже существовала. Но её значение ещё не было присвоено, поэтому мы получали undefined.

bindAll:
for (let key in user) {
  if (typeof user[key] == 'function') {
    user[key] = user[key].bind(user);
  }
}

bind с аргументами:
Например, у нас есть функция send(from, to, text). Потом внутри объекта user мы можем захотеть использовать её частный вариант: sendTo(to, text), который отправляет текст от имени текущего пользователя.

Что если мы хотим зафиксировать некоторые аргументы, но не контекст this? Например, для метода объекта:
function partial(func, ...argsBound) {
  return function(...args) { // (*)
    return func.call(this, ...argsBound, ...args);
  }
}

Как мы помним из главы Методы объекта, "this", у стрелочных функций нет this. Если происходит обращение к this, его значение берётся снаружи.

function f(phrase) {
  return class {
    sayHi() { alert(phrase) }
  }
}
class User extends f("Привет") {}
new User().sayHi(); // Привет
Это может быть полезно для продвинутых приёмов проектирования, где мы можем использовать функции для генерации классов в зависимости от многих условий и затем наследовать их.

class Rabbit extends Animal {
  stop() {
    setTimeout(() => super.stop(), 1000); // вызывает родительский stop после 1 секунды
  }
}
// Unexpected super
setTimeout(function() { super.stop() }, 1000);

static используется для всего класса, а также можно его использовать как фабричный метод

Статические свойства работают только в последних версиях хрома

JSON.Parse(localStorage.getItem('idsBlock'));
localStorage.setItem('idsBlock', JSON.stringify(idsBlock));